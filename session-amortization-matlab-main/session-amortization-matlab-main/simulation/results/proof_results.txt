
#############################################################
#   SESSION AMORTIZATION NOVELTY — FULL VALIDATION SUITE   #
#   Based on: LR-IoTA + Code-Based HE (Kumari et al. 2022) #
#############################################################

>> Running sim_latency.m ...

=============================================================
  SIMULATION 1: Computation Latency Comparison
  Base Paper vs Session Amortization Novelty
=============================================================

--- Base Paper Costs ---
  LR-IoTA authentication:         14.322 ms
  Code-based HE per packet:       7.3728 ms  (enc: 1.5298 + dec: 5.8430)

--- Session Amortization Costs ---
  Epoch Initiation (one-time):    22.5497 ms  (LR-IoTA: 14.322 + QC-LDPC KEP: 8.2277)
  Tier 2 per-packet:              0.0750 ms  (HKDF: 0.002 + AES-GCM: 0.073)

--- Key Results ---
  Per-packet latency reduction:   98.98%
  Break-even point:               N = 4 packets
  At N=50:  Base = 368.6 ms  |  Proposed = 26.22 ms  |  Saving = 342.4 ms
  At N=100: Base = 737.3 ms  |  Proposed = 29.97 ms  |  Saving = 707.3 ms

Figure saved: sim_latency.png

[SIMULATION 1 COMPLETE]

>> Running sim_bandwidth.m ...

=============================================================
  SIMULATION 2: Bandwidth Overhead Comparison
  Base Paper vs Session Amortization Novelty
=============================================================

--- Per-Packet Data Overhead (beyond payload |m|) ---
  Base paper CT0 (syndrome):      408 bits
  Proposed Tier 2 overhead:       224 bits
    - Nonce (96-bit AES-GCM):     96 bits
    - GCM auth tag (128-bit):     128 bits
  Net saving per data packet:     184 bits (45.1% reduction in per-packet OH)

--- Epoch-Level Overhead (sent once, unchanged for both) ---
  LR-IoTA authentication:         26368 bits
    - Public key:                 14848 bits
    - Signature:                  11264 bits
    - Keyword message:            256 bits
  QC-LDPC public key (pk_ds):     1224 bits
  [This authentication overhead is IDENTICAL in base and proposed — unchanged]

--- Cumulative Overhead Savings ---
  At N= 5 packets: Base=29632 bits | Proposed=28712 bits | Saving=920 bits
  At N=10 packets: Base=31672 bits | Proposed=29832 bits | Saving=1840 bits
  At N=25 packets: Base=37792 bits | Proposed=33192 bits | Saving=4600 bits
  At N=50 packets: Base=47992 bits | Proposed=38792 bits | Saving=9200 bits

Figures saved: sim_bandwidth_bar.png, sim_bandwidth_cumulative.png
[SIMULATION 2 COMPLETE]

>> Running sim_energy.m ...

=============================================================
  SIMULATION 3: Clock Cycle Comparison (Energy Proxy)
  Code-Based HE Methods vs Session Amortization Tier 2
=============================================================

--- Code-Based HE Clock Cycles (from master_draft Fig. 7) ---
  Original Lizard:  Enc = 2.30×10^6  |  Dec = 3.20×10^6
  RLizard:          Enc = 3.30×10^6  |  Dec = 4.75×10^6  [worst]
  LEDAkem:          Enc = 0.60×10^6  |  Dec = 2.25×10^6
  Base Paper (Proposed Code-based HE):
    Enc = 0.3500×10^6  |  Dec = 2.0982×10^6  |  Total = 2.4482×10^6

--- Proposed Tier 2 (Session Amortization AEAD) ---
  HKDF-SHA256:  6000 cycles
  AES-256-GCM:  68000 cycles
  TOTAL:        74000 cycles = 0.0740×10^6 cycles

--- KEY RESULT ---
  Clock cycle reduction (base → Tier 2): 33.1×
  Proportional battery life extension:   ~33.1× (same CPU utilization model)

Figure saved: sim_energy.png
[SIMULATION 3 COMPLETE]

>> Running proof1_ind_cca2.m ...

=============================================================
  PROOF 1: IND-CCA2 SECURITY VALIDATION
=============================================================

[TEST 1a] Deriving 1000 session keys from same Master Secret (MS)...
  [PASS] All 1000 session keys are unique. No collisions in HKDF output.
[TEST 1b] Checking pseudorandomness (bit distribution over 1000 keys)...
  Bit distribution mean: 0.498367 (expected 0.5)
  [PASS] Bit mean within 2% of 0.5 → keys are computationally indistinguishable.

[TEST 2] Simulating 10000 chosen-ciphertext attacks (1-bit flip per attempt)...
  Adversary sends tampered ciphertext to decryption oracle.
  AES-GCM verifies TAG over (CT, AD) before decryption — any bit flip must be rejected.

  Results:
    Total CCA2 attempts:        10000
    Rejected:                   10000
    Accepted (false positives): 0
    Rejection rate:             1.0000 (100.000%)
  [PASS] MAC rejection rate ≥ 99.9% → AES-GCM provides IND-CCA2 security.
         Adversary advantage: ε ≈ 0.000000 (negligible).

--- FORMAL IND-CCA2 ARGUMENT ---
Security reduces to:
  1. AES-256 PRF hardness: HKDF output is computationally indistinguishable
     from a random function → session key SK_i is pseudorandom (Proof 1a).
  2. GCM-MAC unforgeability: any modification to CT or AD changes the 128-bit
     authentication tag → decryption oracle outputs ⊥ with prob. ≈ 1 (Proof 1b).
  3. AD binding: AD = DeviceID||EpochID||Nonce_i ensures ciphertext is bound
     to a specific session context → cross-session forgery is impossible.
  Conclusion: No PPT adversary A achieves advantage ε > negl(λ) in the IND-CCA2
  game assuming AES and HMAC-SHA256 are secure PRFs.

======================================
PROOF 1: IND-CCA2 PASSED
======================================
  ✓ 1000 session keys: all unique
  ✓ Bit distribution: 0.498367 ≈ 0.5 (pseudorandom)
  ✓ CCA2 rejection rate: 1.0000 ≈ 1.0

>> Running proof2_replay.m ...

=============================================================
  PROOF 2: STRICT REPLAY RESISTANCE VALIDATION
=============================================================

[TEST 1] Simulating 10000 replay attempts (Nonce_i <= Ctr_Rx)...
  [PASS] Replay rejection: 10000/10000 replays rejected (rate = 1.000000)
         Adversary replay success probability: exactly 0

[TEST 2] Simulating 10000 valid sequential packet arrivals...
  [PASS] Valid acceptance: 10000/10000 packets accepted (rate = 1.000000)
         Final Ctr_Rx = 10500 (correctly advanced)

[TEST 3] Simulating packet drops (20% drop rate, 10000 packets)...
  Sent: 10000 | Dropped: 1967 | Received: 8033 | Accepted: 8033
  [PASS] All received packets accepted despite drops. Counter self-heals correctly.
         No state corruption: Ctr_Rx = 9999 (matches last received nonce)

[TEST 4] Simulating 10000 duplicate delivery attempts...
  [PASS] All 10000 duplicate deliveries rejected (Nonce_i = Ctr_Rx is also rejected).

--- FORMAL REPLAY RESISTANCE ARGUMENT ---
Theorem (Strict Replay Resistance):
  For any packet with Nonce_i ≤ Ctr_Rx:
    Pr[Receiver accepts replayed packet] = 0
  This follows directly from the monotonic counter check (N_i > Ctr_Rx).
  The condition is deterministic (no probability space) → probability exactly 0.

  Corollary: Desynchronization from packet loss does not weaken replay defense.
  The receiver counter self-advances to the last seen valid Nonce,
  rejecting any replay of skipped (dropped) nonces automatically.

======================================
PROOF 2: REPLAY RESISTANCE PASSED
======================================
  ✓ Replay rejection rate: exactly 1.0 (0 false accepts in 10000 trials)
  ✓ Valid packet acceptance: exactly 1.0 (10000/10000)
  ✓ Desynchronization recovery: clean (no state corruption)
  ✓ Duplicate delivery rejection: exactly 1.0

>> Running proof3_forward_secrecy.m ...

=============================================================
  PROOF 3: EPOCH-BOUNDED FORWARD SECRECY (EB-FS) VALIDATION
=============================================================

[TEST 1] Epoch k terminates → MS zeroization protocol...
  Epoch bounds: N_max = 2^20 = 1048576 packets  |  T_max = 86400 s (24h)
  MS_epoch_k (first 4 bytes, pre-zeroization): [5F F3 BB 99]
  Trigger: N_max = 1048576 packets reached
  [PASS] MS_epoch_k is zero-vector after overwrite: [00 00 00 00 ...]
         HKDF(MS=0, Nonce_i) would generate a fixed degenerate key — NOT the original.
  [PASS] Pre-zeroization MS was non-zero; post-zeroization MS is zero. ✓

[TEST 2] Verifying session keys from Epoch k cannot be derived from Epoch k+1 MS...
  MS_epoch_(k+1) (new handshake): [4E 43 32 6E ...]
  Adversary reconstructed 0 / 100 Epoch-k keys using only MS_epoch_(k+1)
  [PASS] Zero key matches — Epoch-k keys are completely isolated from Epoch-(k+1).
         Recovering MS_epoch_k from MS_epoch_(k+1) requires solving Ring-LWE.

[TEST 3] Forward secrecy across a sequence of 5 epochs...
  [PASS] All epoch key-sets are mutually isolated — no cross-epoch key leakage.

--- FORMAL EPOCH-BOUNDED FORWARD SECRECY ARGUMENT ---
Theorem (Epoch-Bounded Forward Secrecy):
  Let ẽ_k and ẽ_{k+1} be independent error vectors from Epoch k and k+1.
  MS_k = HMAC-SHA256(ẽ_k) and MS_{k+1} = HMAC-SHA256(ẽ_{k+1}).

  After epoch termination, MS_k is zeroized (TEST 1 confirmed).
  Then:
    1. Computing MS_k from MS_{k+1} requires finding ẽ_k, which is equivalent
       to solving the Ring-LWE problem:
       Pr[find_search_LWE(λ) = S_ch] ≈ negligible
       (Base paper Theorem 2, Equation 23 — master_draft §11.3)

    2. Inverting HMAC-SHA256 to recover ẽ_k from MS_k (if MS_k is still known)
       requires breaking HMAC-SHA256 as a PRF — negligible under HMAC security.

    3. Once MS_k is zeroized, both paths (1) and (2) are closed simultaneously.
  Conclusion: Past epoch sessions are computationally sealed after epoch termination.
  Epoch bounds N_max = 2^20, T_max = 86400s guarantee timely zeroization.

======================================
PROOF 3: EPOCH-BOUNDED FORWARD SECRECY PASSED
======================================
  ✓ MS zeroization: zero-vector confirmed post-epoch
  ✓ Cross-epoch key isolation: 0 of 100 keys recoverable from wrong-epoch MS
  ✓ Multi-epoch FS: all 5 epoch key-sets mutually isolated
  ✓ LWE hardness: reduces to Ring-LWE (Theorem 2, Eq. 23 — base paper)
  N_max = 2^20 = 1048576 | T_max = 86400 s (24h)

#############################################################
#                  FINAL SUMMARY                           #
#############################################################
Simulations complete.
  sim_latency.m      → 99.0% per-packet latency reduction, break-even N=4
  sim_bandwidth.m    → 184 bits/packet overhead reduction
  sim_energy.m       → 33x clock cycle reduction

Proofs validated.
  proof1_ind_cca2.m          → PROOF 1: IND-CCA2 PASSED
  proof2_replay.m            → PROOF 2: REPLAY RESISTANCE PASSED
  proof3_forward_secrecy.m   → PROOF 3: EPOCH-BOUNDED FS PASSED

All figures saved as PNG in current directory.
See novelty_proof_and_results.md for full formal documentation.
